# Full HTTP Networking Course – Fetch and REST APIs in JavaScript

서버컴퓨터도 클라이언트가 될 수 있기 때문에 그렇습니다.

https://www.youtube.com/watch?v=2JYT5f2isg4

예제가 많은 튜토리얼입니다. 웹크롤러를 바닥부터 만들어보는 과정입니다.

며칠 걸릴 수 있는 튜토리얼입니다.

백엔드 엔지니어를 양성하는 과정의 튜토리얼의 일부입니다.

기본적인 자바스크립트 문법과 ES6 문법도 이해는 해야 수강할 수 있습니다. 물론 강의 중에 부가적인 설명을 제공해주기는 할 것입니다.

# Ch 1 - Why HTTP

왜 HTTP가 의미있는가? 20년전에 이미지 공유는 쉽지 않았습니다. 사진을 찍는 것은 쉬웠습니다. 지금은 찍는 것도 공유하는 것도 쉽습니다.

인스타그램은 인터넷으로 사진 공유를 쉽게 한것이 성공 요인 중 하나입니다.

사이트를 방문할 때마다 하나의 http 프로토콜을 따릅니다. p가 프로토콜입니다. 프로토콜은 단순히 절차에 불과합니다.

"손을 드시오"라고 종이에 적고 전달하면 상대방에게 주면 상대방은 손을 들것입니다. 이것은 하나의 절차입니다. 종이에 작성된 문자와 전달하는 절차가 서로 동의하면 통신이 가능합니다.

인터넷 통신 절차는 유사합니다. 서로 동의한 절차를 따르면 통신이 가능합니다. 그저 정보를 보내고 주고 받는 절차에서 정보를 받아 파싱해서 유용하게 사용이 가능해집니다.

결국 주고받는 바이너리에 불과합니다. 정보를 주고 그 정보를 처리하고 이미지같은 정보를 처리하고 서로 공유하는 것이 상당히 강력하게 해주는 것입니다.

https://boot.dev/course/5d804c54-887a-4c1c-b8c7-b6436f3a132e/cc432d80-1fb1-4a2e-8aa8-7a455a8a1ff1/09ed0562-5760-4a78-919a-0233fa9b3227

```js
const apiKey = generateKey();
const items = await getItemData();

logItems();

// don't touch below this line

async function getItemData() {
  const response = await fetch(
    "https://api.boot.dev/v1/courses_rest_api/learn-http/items",
    {
      method: "GET",
      mode: "cors",
      headers: {
        "X-API-Key": apiKey,
        "Content-Type": "application/json",
      },
    }
  );
  return response.json();
}

function generateKey() {
  const characters = "ABCDEF0123456789";
  let result = "";
  for (let i = 0; i < 16; i++) {
    result += characters.charAt(Math.floor(Math.random() * characters.length));
  }
  return result;
}

function logItems(items) {
  for (const item of items) {
    console.log(item.name);
  }
}
```

문제입니다. `getItemData`은 서버에 데이터를 요청합니다.

```js
const apiKey = generateKey();
const items = await getItemData();

logItems(items);

// Healing Potion

// Light Leather

// Padded Leather

// Haste Potion

// Leather Scraps

// Copper Ore

// Copper Bar

// Iron Ore

// Iron Bar

// Gold Ore
```

http의 요청응답시스템입니다. 클라이언트는 우리가 다루는 컴퓨터입니다. 그리고 서버는 요청에 응답받는 컴퓨터입니다. 서버는 프로세스를 처리하고 응답을 합니다. 이것이 요청응답 라이프사이클입니다.

단순하게는 질문 응답시스템으로 생각하는 것이 직관적입니다.

클라이언트는 서버에 요청하고 서버는 웹사이트로 응답하는 경우가 상당히 일반적입니다. URL을 접속하면 서버는 URL에 해당하는 응답을 합니다.

JSON은 URL에서 일반적인 데이터를 얻는 방법입니다.

컴퓨터에게 어떤 요청을 하게 만들지 지정해두는 것입니다. https 이외 다양하게 존재합니다. 하지만 http만이 url을 사용하는 것은 아닙니다.

일반적으로 프론트엔드는 클라이언트에 존재합니다. 사용자가 보는 것은 정의합니다. 백엔드는 보이지 않는 나머지 모든 것입니다.

youtube를 키면 인터페이스가 바로 보입니다. 이것은 시각적인 인터페이스입니다. 당연히 휴대폰에는 모든 유튜브 데이터를 저장하지 않습니다. 이 데이터를 얻어오기 위해 백엔드에 요청을 보냅니다. 유튜브 데이터센터 백엔드는 그 요청을 처리해줍니다. 컴퓨터가 요청을 보내고 처리하고 응답하는 관계가 생깁니다. 유튜브를 보는 휴대폰이 프론트엔드이고 응답하는 컴퓨터는 백엔드 서버입니다. 클라이언트는 영상도 있지만 댓글도 존재합니다. 어떤 서버는 영상을 저장하고 어떤 서버는 댓글을 따로 저장합니다. 백엔드의 경우 영상으로 응답하기 전에 다른 댓글을 보관하는 백엔드에게 요청을 보냅니다. 이렇게 되면 요청을 보낸 서버가 클라이언트가 됩니다. 클라이언트와 서버는 요청과 응답의 맥락상 존재하는 관계에 따라 다릅니다.

서버컴퓨터도 클라이언트가 될 수 있기 때문에 그렇습니다.

Fetch API는 단순히 요청을 제어하는 자바스크립트 내장 함수와 도구들입니다. 모든 로직을 바닥부터 작성해야 하면 재앙일 것입니다.

```js
const response = await fetch(url, settings);
const responseData = await response.json();
```

`fetch`는 브라우저가 제공합니다. `url`이 첫번째 인자입니다. `await`는 비동기 처리합니다. 요청을 보내고 잠시 다른 일을 처리하는 키워드입니다.

JSON 데이터를 응답으로 받는 것을 알 수 있습니다. `response.json()`은 응답을 파싱처리해줍니다.

```js
const apiKey = generateKey();
const url = getURL();
const settings = getSettings();

const response = fetch(url, settings);
const responseData = await response.json();

logItems(responseData);

// don't touch below this line

function getSettings() {
  return {
    method: "GET",
    mode: "cors",
    headers: {
      "X-API-Key": apiKey,
      "Content-Type": "application/json",
    },
  };
}

function getURL() {
  return "https://api.boot.dev/v1/courses_rest_api/learn-http/items";
}

function generateKey() {
  const characters = "ABCDEF0123456789";
  let result = "";
  for (let i = 0; i < 16; i++) {
    result += characters.charAt(Math.floor(Math.random() * characters.length));
  }
  return result;
}

function logItems(items) {
  for (item of items) {
    console.log(item.name);
  }
}
```

클라이언트 컴퓨터는 서버인 경우는 대부분 없습니다. 모바일은 당연히 HTTP client이지만 컴퓨터이기 때문에 서버로 활용하는 것도 가능하지만 대부분의 경우 클라이언트입니다.

```js
const apiKey = generateKey();
const url = getURL();
const settings = getSettings();

const response = await fetch(url, settings);
const responseData = await response.json();

logItems(responseData);
```

서버는 시동하면 요청을 받도록 대기만하고 항상켜져있습니다. 많은 어플리케이션이 그런 방식으로 동작하지 않습니다. 서버만 조금 특이한 점입니다. 또 필요하면 수동으로 꺼야 합니다.

좋은 웹 서버는 항상켜져있습니다.

서버는 당연히 백엔드 어플리케이션입니다. 시각적으로 제어하지 않습니다.

모든 컴퓨터는 서버가 될 수 있습니다. 하지만 서버는 데이터를 제공하기 위해 만들어졌습니다. 이것을 논하기 전에 현대 인터넷의 동작방식을 이해해야 합니다. 일반적으로 새로운 웹 회사는 데이터센터에 서버를 구동합니다. 그런 컴퓨터는 서버사이드 작업에 최적화되어 있습니다. 현실적으로 모든 컴퓨터에 서버를 구동할 수 있습니다. 개발하는 동안에는 개인용컴퓨터에 구동시키는 경우가 일반적이지만 프로덕션에서 비용당 효율이 높은 것은 서버 컴퓨터를 활용하는 것이 좋습니다.

# ch 2 - DNS

https://youtu.be/2JYT5f2isg4?t=1652

https://boot.dev/course/5d804c54-887a-4c1c-b8c7-b6436f3a132e/32b924f8-c32a-458b-bab4-2eab421749de/73a84056-e022-4f1f-9192-be8a6231d2ed

웹 주소입니다. 저는 저의 컴퓨터가 있고 다른 서버랑 통신하고 싶습니다. 문제는 인터넷은 저의 컴퓨터와 서버보다 더 다양한 컴퓨터들이 존재합니다. 어떻게 저는 라우팅 방식을 이해해서 직접 그 특정 서버랑 통신하는가? 이 때 들어오는 개념이 웹 주소 IP입니다.

8.13.156.7 이렇게 생겼습니다. 4개의 영역으로 점으로 나누어져있습니다. 하나의 영역당 0~255에 값을 가질 수 있습니다. 이외 다양한 주소들을 가질 수 있지만 일단 간단하게 이해하겠습니다.

주소는 쿠팡택배가 혼란없이 우리집에 도착할 수 있게 해주는 것처럼 IP도 동일합니다. IPv4는 방금 이야기 한 주소 형식입니다. 하지만 IPv6는 더 많이 수용할 수 있습니다. 또 콜론으로 구분합니다. 1:1:1:1:1:0 이렇게 생겼습니다. 더 많은 경우의 수를 수용할 수 있습니다. 지금은 IPv4만으로 부족해지고 있습니다. 그래서 IPv6가 점진적으로 활용됩니다.

그래서 IP주소는 2가지를 자주 보게 될 것입니다.

IP 주소를 제공하면 어디서는 열결되어 있으면 통신할 수 있습니다. 반면 쿠팡 IP 주소를 딱히 알지 않습니다. 아무도 이렇게 안 외웁니다. 이때 필요한 것은 DNS입니다. 사람이 읽을 수 있게 IP를 바꿔줍니다. 컴퓨터는 도메인을 IP로 변환하고 통신합니다. 쿠팡이 IP를 변경하면 이렇게 IP를 몰래 변경하고 도메인은 그대로 유지할 수 있습니다. 물론 이렇게 되면 유저는 모르는 경로만 바뀔 뿐입니다. 도착은 갖지만 가는길만 조금 달라집니다.

서버에게 http요청은 2단계가 존재합니다.

1. DNS를 Resolve합니다. 도메인 이름을 IP로 처리합니다.
2. IP 주소를 사용해서 해당하는 요청을 보냅니다.

```url
https://en.wikipedia.org/wiki/Miniature_pig
```

`en.wikipedia.org`이 도메인에 해당합니다.

```js
async function fetchIPAddress(domain) {
  const resp = await fetch(
    `https://cloudflare-dns.com/dns-query?name=${domain}&type=A`,
    {
      headers: {
        accept: "application/dns-json",
      },
    }
  );
  const respObject = await resp.json();

  console.log(respObject);
}

// don't touch below this line

const domain = "api.boot.dev";
const ipAddress = await fetchIPAddress(domain);
if (!ipAddress) {
  console.log("something went wrong in fetchIPAddress");
} else {
  console.log(`found IP address for domain ${domain}: ${ipAddress}`);
}
```

문제입니다.

> {"Status":0,"TC":false,"RD":true,"RA":true,"AD":true,"CD":false,"Question":[{"name":"api.boot.dev","type":1}],"Answer":[{"name":"api.boot.dev","type":1,"TTL":3600,"data":"34.111.29.119"}]}
>
> something went wrong in fetchIPAddress

이렇게 응답받은 객체가 IP만 반환하도록 처리합니다.

```js
async function fetchIPAddress(domain) {
  const resp = await fetch(
    `https://cloudflare-dns.com/dns-query?name=${domain}&type=A`,
    {
      headers: {
        accept: "application/dns-json",
      },
    }
  );
  const respObject = await resp.json();

  return respObject.Answer[0].data;
}

// don't touch below this line

const domain = "api.boot.dev";
const ipAddress = await fetchIPAddress(domain);
if (!ipAddress) {
  console.log("something went wrong in fetchIPAddress");
} else {
  console.log(`found IP address for domain ${domain}: ${ipAddress}`);
}
```

정답입니다.

프로그래밍적으로 체크랑 런타임 에러가 발생하지 않도록 만들 수 있습니다.

인터넷에 IP, 도메인을 통해 배포할 때는 웹사이트에 해당하는 HTML, CSS, JavaScript파일과 배포 프로그램이 있어야 합니다. 그리고 배포 기계가 필요합니다. 보통 클라우드 서비스가 대여해줍니다. 서비스가 기계를 대여해주고 배포를 처리해서 IP를 제공해줍니다. 그렇게 되면 도메인을 구매하고 IP를 입력합니다. 도메인이 IP를 가리키게 만듭니다. 이것이 하이레벨입니다.

자바스크립트는 url 파싱처리해주는 API을 갖고 있습니다.

```js
const urlObj = new URL("https://example.com/example-path");
```

```js
function getDomainNameFromURL(url) {
  // ?
}

// don't touch below this line

const bootdevURL = "https://boot.dev/learn/learn-python";
const domainName = getDomainNameFromURL(bootdevURL);
console.log(`The domain name for ${bootdevURL} is ${domainName}`);
```

문제입니다. url 파싱해서 호스트 이름을 알아내는 것입니다.

https://developer.mozilla.org/ko/docs/Web/API/URL

mdn 스펙입니다.

```js
function getDomainNameFromURL(url) {
  const urlObj = new URL(url);
  return urlObj.hostname;
}

// don't touch below this line

const bootdevURL = "https://boot.dev/learn/learn-python";
const domainName = getDomainNameFromURL(bootdevURL);
console.log(`The domain name for ${bootdevURL} is ${domainName}`);
```

정답입니다.

DNS는 비유적으로 컴퓨터를 위한 거대한 전화번호부입니다. 확인하고 주소를 찾습니다. 내부 동작원리가 있습니다.

ICANN이 모든 DNS를 운영합니다. ICANN에서 루트네임서버를 찾아서 연락합니다. 그리고 IP 주소를 resolve합니다.

루트 네임서버는 컴퓨터에 기본값으로 설정되어 있습니다.

ICANN은 전화번호부의 출판사와 비슷합니다.

ICANN은 DNS를 구동하는 일도합니다.

DNS는 도메인 이름을 IP주소로 변환해주는 시스템입니다.

서브 도메인입니다. 도메인이름을 프리픽싱합니다. 도메인이름은 호스팅합니다. 서브 도메인은 웹이 서버랑 통신해서 통신하기 위한 도메인입니다. 서브 도메인은 호스트 된 리소스를 분할 관리할 수 있습니다.

```js
const bootdevAPIDomain = "boot.dev";

// don't touch below this line
const apiKey = generateKey();
const items = await getItemData(bootdevAPIDomain);

logItems(items);

async function getItemData(domain) {
  const response = await fetch(
    `https://${domain}/v1/courses_rest_api/learn-http/items`,
    {
      method: "GET",
      mode: "cors",
      headers: {
        "X-API-Key": apiKey,
        "Content-Type": "application/json",
      },
    }
  );
  return response.json();
}

function generateKey() {
  const characters = "ABCDEF0123456789";
  let result = "";
  for (let i = 0; i < 16; i++) {
    result += characters.charAt(Math.floor(Math.random() * characters.length));
  }
  return result;
}

function logItems(items) {
  for (item of items) {
    console.log(item.name);
  }
}
```

문제입니다. API가 바뀌면 1가지 변수만 변형하면 됩니다.

서브도메인 api에 호스팅이 되어 있습니다. 이런 이유로 버그를 고치도록 합니다.

Problem is, there is a bug. The API isn't hosted on boot.dev, it's hosted on the api subdomain! Fix the bug.

> SyntaxError: Unexpected token '<', "<!DOCTYPE "... is not valid JSON

```js
const bootdevAPIDomain = "api.boot.dev";
```

# URIs and URLs

https://youtu.be/2JYT5f2isg4?t=2896

https://boot.dev/course/5d804c54-887a-4c1c-b8c7-b6436f3a132e/ae6b0872-c370-41a7-8ba9-f54e216afaec/d3370885-b345-48e2-b9a0-2dcc8f92903b

URI를 가끔 보게 될 것입니다. URL의 상위 개념입니다. I는 식별자입니다. URL은 URL의 종류입니다. URN도 존재합니다.

일반적으로 인터넷은 URL을 다루지만 URI를 보고 당황하지 않도록 합니다. 가끔은 URI를 넣어야 하지만 URL를 넣는 경우도 있습니다.

URI 속에 URL, URN이 포함됩 관계입니다.

```js
function printURLParts(urlString) {
  const urlObj = new URL(urlString);
  // ?
}

// don't touch below this line

const fantasyQuestURL =
  "http://dragonslayer:pwn3d@fantasyquest.com:8080/maps?sort=rank#id";
printURLParts(fantasyQuestURL);
```

연습 문제입니다. url을 보고 이해해보도록 합니다.

연습 문제를 풀기 위한 개념입니다.

```url
http://testuser:testpass@testdomain.com:8080/testpath?testsearch=testvalue#testhash
```

여기서 영역별 설명입니다.

```txt
protocol: http:
username: testuser
password: testpass
hostname: testdomain.com
port: 8080
pathname: /testpath
search: ?testsearch=testvalue
hash: #testhash
```

url에서 username, password는 보게 될 수 있지만 아주 가끔입니다. 하지만 입력하지 않게 합니다. 보통 form 제출로 들어가도록 합니다. @은 호스트 네임과 분할합니다.

port는 http는 80이 기본 값입니다. https는 443가됩니다. 브라우저는 기본적으로 port를 명시하지 않습니다.

path는 웹 사이트에서 다른 페이지별 라우팅을 구분할 때 사용합니다. 페이지 라이팅은 중첩될 수 있습니다.

search는 쿼리 파라미터라는 용어가 더 좋습니다. 물음표 뒤에 다양한 매개변수를 갖게 만들 수 있습니다. 나중에 다룹니다.

해쉬 혹은 프라그먼트라고 합니다. 페이지의 구체적은 섹션에 해당하는 영역을 표시할 때 자주 활용합니다. 또 웹사이트 맥락과 다르게 활용할 때듀 많습니다.

또 URL API를 활용합니다.

Use the following properties on the URL object:

- protocol
- username
- password
- hostname
- port
- pathname
- search
- hash

```js
function printURLParts(urlString) {
  const urlObj = new URL(urlString);
  console.log(`protocol: ${urlObj.protocol}`);
  console.log(`username: ${urlObj.username}`);
  console.log(`password: ${urlObj.password}`);
  console.log(`hostname: ${urlObj.hostname}`);
  console.log(`port: ${urlObj.port}`);
  console.log(`pathname: ${urlObj.pathname}`);
  console.log(`search: ${urlObj.search}`);
  console.log(`hash: ${urlObj.hash}`);
}

// don't touch below this line

const fantasyQuestURL =
  "http://dragonslayer:pwn3d@fantasyquest.com:8080/maps?sort=rank#id";
printURLParts(fantasyQuestURL);
```

url의 8가지 부분입니다.

![url의 8가지 부분](https://user-images.githubusercontent.com/84452145/219051508-d97cdcb9-c4e9-44bb-8810-9efe1fffe941.png)

url을 보면 어떤 프로토콜을 사용하는지 알아야 합니다. 선택적이지 않습니다. 리소스가 사용자명과 비번이 없으면 public 취급합니다. 선택적입니다. 도메인은 당연히 필수입니다. 어디를 접근하는지 알아야 합니다. port는 모든 프로토콜이 존재하지만 안 보일 뿐입니다. port를 볼 때는 스스로 개발할 때 접근하게 됩니다. path는 선택적이지만 `/`은 최소한으로 반드시 존재합니다. 쿼리와 프라그먼트는 당연히 선택적입니다.

암기하려고 노력하기 보단 자주 작업하면서 암기되는 지식입니다.

필수적으로 프로토콜과 도메인이 제일 중요합니다.

프로토콜 연습문제입니다.

- http
- ftp
- mailto
- https

http//에 //이 존재하는 이유는 필수적으로 존재합니다. 또 권위자로 인정하기 때문에 그렇습니다. 하지만 mailto는 콜론으로 끝납니다.

```js
function getMailtoLinkForEmail(email) {
  // ?
}

// don't touch below this line

let email = "slayer@fquest.app";
console.log(`The mailto link for ${email} is: ${getMailtoLinkForEmail(email)}`);
email = "killer@fquest.app";
console.log(`The mailto link for ${email} is: ${getMailtoLinkForEmail(email)}`);
```

```js
function getMailtoLinkForEmail(email) {
  return `mailto:${email}`;
}

// don't touch below this line

let email = "slayer@fquest.app";
정email = "killer@fquest.app";
console.log(`The mailto link for ${email} is: ${getMailtoLinkForEmail(email)}`);
```

정답입니다.

이제부터 Prot 개념입니다. 웹서비스를 운영하고 있습니다. 저의 서버로 웹을 접근하기 위해 서버에 요청을 보냅니다. 하지만 여기서 문제입니다. 같은 기계에 여러개의 서버를 호스팅하고 싶습니다. 예를 들어 데이터 베이스를 운영하고 싶습니다. Port는 받는 요청을 처리해주는 입구입니다. 같은 기계에 각각 다른 요청을 독립적으로 처리하게 만들 수 있습니다.

예를 들어 하나는 80 다른 하나를 432로 구동하면 각각 port에서 요청을 처리하게 됩니다.

컴퓨터 1대당 65,000 정도 포트를 만들 수 있습니다.

port가 url에 안 보이면 해당하는 프로토콜의 기본값을 대입하고 처리합니다.

http, https는 80, 433을 기본으로 하지만 다른 port를 사용하는 것도 당연히 가능합니다.

전통적인 파일서버는 라우팅을 path를 랜더링 처리합니다. 관습입니다. 라우트 path를 해당하는 파일이름을 랜더링하도록 합니다.

관습적으로 정적 파일 서버는 해당하는 path를 디스크를 url로 처리합니다. 많은 프레임워크는 커스텀 로직으로 path에 따라 각각 다르게 핸들링하게 해줍니다. 그래서 반드시 대응하는 것은 아닙니다.

URL은 해당하는 파일은 웹사이트에는 일반적입니다. 하지만 웹 API에서는 아닙니다.

연습문제입니다.

```js
const url = "https://api.boot.dev/v1/courses_rest_api/learn-http/users";

// don't touch below this line
const apiKey = generateKey();
const response = await fetch(url, {
  method: "GET",
  mode: "cors",
  headers: {
    "X-API-Key": apiKey,
    "Content-Type": "application/json",
  },
});

const responseData = await response.json();

logLocations(responseData);

function generateKey() {
  const characters = "ABCDEF0123456789";
  let result = "";
  for (let i = 0; i < 16; i++) {
    result += characters.charAt(Math.floor(Math.random() * characters.length));
  }
  return result;
}
function logLocations(locations) {
  for (const location of locations) {
    console.log(
      `Location: ${location.name}, Recommended Character Level: ${location.recommendedLevel}`
    );
  }
}
```

api는 path를 파싱하고 해당하는 프론트엔드 로직을 처리하도록 합니다.

여기서 users path말고 locations path가 필요합니다.

```js
const url = "https://api.boot.dev/v1/courses_rest_api/learn-http/locations";
```

쿼리 파라미터는 요청에서 아주 작은 부분을 변경합니다. 서버는 결국 뭐든 할 수 있습니다. 하지만 쿼리 파라미터는 관습상 변화가 작습니다.

```url
https://www.google.com/search?q=hello+world&oq=hello+world&aqs=chrome..69i57j0i512l3j46i512j0i512j69i60l2.5105j0j7&sourceid=chrome&ie=UTF-8
```

구글에 hello world를 검색한 url입니다. 여기서 `?q`을 발견할 수 있습니다. 즉 검색할 범위를 선정하게 된 것입니다.

검색마다 path를 새로 만들기에는 상당히 비효율적입니다. 새로운 페이지가 딱히 필요하지 않습니다.

쿼리를 동시에 할 수 있습니다. `&`을 활용하는 것입니다.

쿼리 파라미터는 페이지 제어는 가장 덜 활용합니다. 콘텐츠를 제어하거나 마케팅 웹 분석에 많이 활용합니다.

# Async JavaScript

https://youtu.be/2JYT5f2isg4?t=4581

https://boot.dev/course/5d804c54-887a-4c1c-b8c7-b6436f3a132e/c8469dda-3040-4c4a-9d14-2e2ec5678589/595e1c3e-c01c-4110-bdbd-15db31c25192
