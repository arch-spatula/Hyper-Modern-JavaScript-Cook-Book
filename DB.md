# DB 설계 특강

프론트엔드를 위한 기초 지식을 쌓기 위한 수준입니다. 학습 목표 3가지만 잘하면 됩니다.

DB처음 공부하면 혼란이 많이 발생할 수 있습니다.

프론트엔드는 DB 질문을 많이 받는 편은 아닙니다.

이 자리는 개론을 배우는 시간입니다. DB는 백엔드가 많이 다루고 또 때로는 데이터 엔지니어도 따로 있을 때가 많습니다.

데이터 베이스란 무엇인가? 좁은 의미로 데이터의 모음입니다. 넓은 의미로 개발자들의 의미는 DBMS로 제어하고 데이터의 모음을 같이 포함한 의미로 사용합니다. 개발자들이 DB라고 물으면 DBMS도 같이 있는 것입니다.

DBMS는 데이터의 나열을 프로그래밍으로 제어하는 것입니다. 확인, 성능향상, 복구, 저장 등 다양한 작업을 합니다.

가장 많이 사용되는 것은 관계형 데이터 베이스입니다. RDBMS입니다. 엑셀 테이블처럼 표형태로 데이터를 넣는 방식입니다.

장점은 직관적이고 데이터 관계파악이 쉽습니다.

메모리를 절약하기 위해 데이터의 중복을 최대한 절약하는 방법을 보고 정규화, 범주화입니다. DB 성능향상은 어렵습니다. 하드웨어로 개선하는 것도 방법이지만 당연히 한계가 있습니다. 단점은 적재가 어렵습니다.

데이터 베이스를 만들때는 처음부터 설계를 잘해야 정검시간을 없이 해결할 수 있습니다.

스케일 업은 컴퓨터의 공간을 더 많이 확보하는 것으로 해결합니다.

스케일 아웃은 컴퓨터 대수를 늘리는 방법입니다. 정확성은 떨어집니다.

데이터 베이스를 상호작용하기 위해 필요한 언어는 SQL입니다. 프로그래머스에서도 SQL 연습문제를 제공합니다. 풀어볼 것을 권장합니다.

쿼리는 요청하고 응답받기 위한 행위입니다.

SQL 자체는 직관적입니다. 입문이 상당히 쉬울 것입니다.

몽고 DB, 파이어 베이스는 SQL 문법을 사용할 필요는 없지만 역사와 전통과 레거시를 대응하기 위해서는 SQL을 학습해야 합니다.

NoSQL도 입문하기 상당히 쉽습니다. 관계형 데이터 베이스만이 아닌 모든 곳에 사용하기 위해서 사용합니다. 간단한 정의는 SQL만 사용하지 않는다.입니다.

SQL은 마트 재고, 학교 학생 통계 같은 정형화된 데이터 많이 사용했습니다. 하지만 현실은 정형화되지 않은 데이터도 많이 있습니다. 정확성이 별로 중요하지 않으면 스케일 아웃 전략과 함께 NoSQL을 사용하게 되었습니다.

아마존에서 제일 유명한 DB는 다이나모 DB입니다. 나중에 논문 요약이라도 읽기를 권장합니다.

독큐먼트 데이터 베이스는 폴더속에 넣는 것같은 관계 때문에 붙은 이름입니다. 몽고 DB랑 파이어 베이스가 여기에 해당합니다.

# FIREBASE 특강

오늘 강의는 특강이 아닙니다. 반드시 들어야 하는 정규강의처럼 생각해주시기 바랍니다. 이 강의는 중요합니다. 다음 프로젝트에 사용할 개념입니다. 이전 MPA 프로젝트에서 더 발전할 것입니다.

리액트가 주특기인 개발자는 백엔드 개발자랑 협업을 많이 못합니다. 하지만 프로젝트는 풀스택으로 개발해야 합니다. 파이어 베이스를 공부하면 프론트엔드에 집중하기 편안합니다. 서비스 설정에 5분 미만에 간단하게 할 수 있습니다. 코드 스니펫 몇번에 간단하게 DB를 만들 수 있습니다.

이전 개념인 SPA랑 연결될 것입니다.

오늘 수업을 다 들으면 6가지 개념을 모두 설명할 수 있어야 합니다.

- [ ] SPA를 설명할 수 있어야 합니다.
- [ ] Auth 서비스의 용도를 설명할 수 있습니다.
- [ ]

파이어 베이스의 서비스는 24개가 있지만 3가지만 사용합니다. 3가지 용도는 모두 말할 수 있어야 합니다.

서버 코드는 거의 안 만집니다. 서버를 따로 안 만들 것입니다. 그래서 배포 방식도 다릅니다. 정적 웹 호스팅을 하는 다른 전략이 있습니다. 이전 AWS 활용하는 것보다 더 간단합니다.

권장항목이지만 무조건 할 필요는 없습니다. 가비아에서 도메인을 구입하고 연결하는 법은 알것을 권장합니다. 간략한 네트워크 지식으로 시도할 수 있습니다.

로그인, 회원가입할 때 유효성 검사도 시도해보도록 합니다. 미리 공부할 것입니다. 많은 학습이 필요한 것이 아닙니다.

권장항목 2개는 필수 개념입니다.

서비리스부터 공부하겠습니다. 파이어베이스는 서버리스랑 개념적으로 밀접합니다. 서버리스는 서버관리가 필요없는 서비스입니다. 그래서 서버관리가 필요없다인 것이지 서버가 없는 것이 아닙니다. 서버리스의 등장배경을 봅시다. 이해에 좋습니다.

처음 배포의 역사입니다. 대부분의 서비스는 가정집 차고에서 서비스를 시작했습니다. 서비스가 성공하면 서버컴퓨터를 더 추가하고 서버룸을 더 추가하는 방식이었습니다. 하지만 서버 컴퓨터 유지보수는 관리가 어럽습니다. 서버 컴퓨터를 빌리는 서비스가 나오기 시작했습니다. 원격으로 서버 컴퓨터를 빌리는 개념입니다. AWS EC2가 대표적인 예시입니다. 하드웨어는 아마존이 관리하게 됩니다.

시장 반응을 보고 백엔드 엔지니어 채용을 결정하고 싶기 때문에 백엔드 엔지니어를 고용하기 전에 소프트웨어 관리 위임으로 등장하게 된것이 파이어 베이스, AWS lambda가 탄생하게 되었습니다.

AWS lambda는 API 함수를 직접만들어줘야 합니다. 만든 것을 호출할 수 있게 해서 서버리스 서비를 만든 것입니다. 그래서 FaaS입니다. F는 함수입니다. 파이어 베이스는 BaaS입니다. 백앤드를 대신하게 된 것입니다.

여기까지가 서버리스입니다.

파이어 베이스는 별도의 서비스나 DB를 직접 관리할 필요 없이 이용할 수 있는 백엔드 플랫폼입니다.

Authentication은 로그인
Cloud Firestores는 데이터베이스에 접근할 수 있는 API CRUD를 제공합니다.
Storage는 파일을 저장하고 다운 받을 수 있습니다.

당연히 파이어 스토어는 부분 유료입니다. 유료전환해야 할 일은 거의 없습니다.

AWS랑 다르게 미리 카드 등록할 필요가 없습니다. 처음부터 카드를 요구하지 않습니다. 허용량을 초과하면 서버에서 에러를 돌려주거나 비용폭탕 취약점에서 벗어날 수 있습니다.

기초 프로젝트는 CRUD를 모두 할 수 있어야 합니다. CRUD는 당연히 본인이 작성한 것만 가능해야 합니다. 로그인을 할 수 있으면 프로필관리를 할 수 있어야 하고 로그아웃 기능고 같이 필요합니다.

새로고침이 없다는 것은 CSR이 적용되었다는 것을 알 수 있습니다.

로직을 먼저 보여주는 이유는 기획 의도를 파악하고 코드를 봐야 코드를 쉽게 이해할 수 있습니다. 나중에 프로젝트에 적용할 때는 녹화를 따라해도 됩니다. 그리고 강의가 끝나면 코드 한번더 보고 공부하도록 합니다.

스토리지는 이미지를 저장하고 링크를 가져오는 개념입니다.

데이터 베이스의 변형이 가해지면 전체 목록을 확인하는 것을 보고

파이어 베이스 다이어그램은 파악하도록 합니다.

파이어 베이스 모듈을 보도록 합니다. 프로젝트 설정이 firebaseConfig 객체에 들어있습니다.

사용할 서비스마다 함수를 호출해서 사용하고 `export`하는 것입니다.

파이어 베이스 셋업입니다. 지식은 구글로 찾을 수 있습니다. 암기는 나중에하고 감을 잡으면 무엇을 검색해야 할지 방향이라도 찾을 수 있습니다.

구글 애널리틱스를 추가힐지 말지 결정할 수 있지만 나중에 해도 됩니다. 프로젝트 만들기를 합니다. 프로젝트를 만들면 앱에 추가하는 법으로 웹 마크를 추가하면 됩니다. 앱 이름을 만듭니다. 호스팅은 AWS로 할 것입니다. 그래서 안하기 선택하면 됩니다. 강의 자료 스니펫을 활용하는 게 더 편할 것입니다.

리액트는 npm 사용을 할 것이지만 지금은 스크립트 태그 사용을 할 것입니다. 사용할 서비스 열기만 하면 됩니다. 이메일 비밀번호 로그인 회원가입을 추가할 수 있습니다. 구글 로그인 지원도 추가할 수 있습니다. 깃헙 설정은 조금 복잡합니다. OAuth는 소셜 로그인을 지원하는 github의 기능이 있습니다.

참고로 사용자 계정 연결하고 ID 공급업체별로 여러 계정 만들기를 설정하도록 합니다. 같은 이메일 주로로 로그인할 수 있습니다.

또 서비스 추가로 네이버, 카카오도 커스텀으로 추가할 수 있습니다.

승인된 도메인은 가비아에서 구매하면 파이어 베이스로 연결할 수 있습니다.

이렇게 하면 백엔드 고민을 많이 줄일 수 있습니다.

FireStore는 데이터 베이스를 관리할 수 있습니다. 지역은 우리나라를 고릅니다. 그러면 설정이 된 것입니다. CRUD API만 정해진대로 사용하면 됩니다.

Storage는 데이터 베이스랑 동일한 위치로 설정할 수 있습니다.

3가지 서비스를 연결하면 사이드바에 추가됩니다.

파이어 베이스는 문서화가 상당히 잘 되어 잇습니다. 특별한 기능을 사용하고 있으면 문서찾아보는 것을 권장합니다.

SPA로 모듈 전략입니다. 자바스크립트 파일을 분할 할 수 있습니다. 코드 분할하는 것이 좋은 방법입니다. ES6문법의 모듈 기능을 활용하면 됩니다. 이전에 컴포넌트는 모듈의 하위 개념입니다.

main.js를 기준으로 둡니다.

authService는 유저정보를 갖고 있는 객체입니다. 로그인인지 아닌지 모니터링할 수 있습니다.

window 객체를 통해서만 이벤트를 처리할 수 있습니다. 모듈은 전역으로 사용할 수 없습니다.
스크립트 태그에서 타입을 module로 넣어야 합니다.

모듈에서 사용하는 메서드를 전역 객체 속성에 달아두고 다른 모듈에서도 접근할 수 있습니다. 전역객체를 안 사용하려면 모든 자바스크립트를 한 파일에 담으면 됩니다.

앞으로는 서버리스 환경에서 개발하는 경우가 많을 수 있습니다. 그래서 라이브 서버를 많이 사용할지도 모릅니다.

클라이언트에서 유효성 검사를 먼저 진행합니다. 정규표현식으로 유효성을 검사합니다. 정규표현식은 현재는 잘 몰라도 괜찮습니다. 이메일 형식을 지정하는 규칙이라는 것만 파악하면 됩니다. 정규표현식은 검색하고 테스트를 잘하면 됩니다. 나중에 별도로 공부하고 코딩테스트할 때 문자열처리할 때 꽤 도움이 많이 됩니다.

규칙을 정의하고 안 맞으면 비어있는 `return`을 합니다. 함수를 의도적으로 중단시키는 것입니다.

authBTN로 제출합니다. 로그인 혹은 회원가입에 따라 조건문으로 다르게 처리합니다.

이니셜 페이지 로딩을 할 때는 데이터를 불러와야 합니다. Auth에서 프로필 정보를 가져옵니다. 그리고 댓글들은 파이어 스토어에서 가져옵니다.

DOM을 조작할 때는 화면에 보여지는 요소만 조작할 수 있습니다. 화면에 없으면 선택할 수 없습니다. 선택을 해야 업데이트하고 조작이 가능합니다.

화면에 있는 DOM을 선택하기 위해 조건문으로 제약을 두는 것입니다. 그래서 path로 조건을 걸어두도록 합니다.

`??`은 null 병합연산자입니다. `??`이 존재하기 전까지는 삼항연산자를 많이 사용했습니다. 더 간결하게 사용할 수 있게 해줍니다. (null & undefined 아니면 실행) ?? (null & undefined이면 실행하기)입니다.

이미지 업로는 어려운 개념입니다. 프로필 변경을 하면 changeProfile 함수를 실행합니다. 클릭 여러번 하는 사람 때문에 disable 속성을 true로 업데이트합니다.

imgRef는 스토리 서비스에서 어떤 폴더를 접근하고 그 파일의 uid로 접근합니다. uuidv4() 함수 해쉬값으로 이미지 url을 얻습니다.

유저마다 해쉬값을 갖습니다. 파일이름은 uuidv4()으로 해쉬값을 추가로 붙이는 것입니다.

이미지 핸들링할 때는 다양한 방식으로 처리할 수 있습니다. data_url은 이미지를 url에 올리는 것입니다. 다운로드 url은 이미지를 올려놓은 url에서 가져오는 것입니다.

onFileChange는 이벤트입니다. 라벨을 클릭하면 이미지를 클릭하는 것이랑 동일한 취급을 받습니다. 이미지를 클릭하는 것이지만 사실 type이 파일인 input을 클릭하는 것입니다.

FileList는 html의 input 타입이 파일일 때 지원합니다.

FileReader는 돌랍게도 npm 설치 없이 내장객체입니다. MDN 문서를 읽어보도록 합니다.

onloadend는 데이터 url을 다룰 수 있습니다.

프로필 변경전까지는 로컬 스토리지로 저장하고 변경하고 싶을 때 업데이트합니다. 변경을 저장할 때 데이터로 저장하도록 제어하는 방법입니다.

코드의 CRUD만 이해하면 코드 리뷰는 끝납니다.

CRUD 구현입니다.

Create는 saveComment 함수를 실행합니다. id 선택을 합니다. 객체 구조분해할당으로 사용할 정보를 뺍니다.

DB로 addDoc으로 보냅니다. uid는 나중에 사용자별로 삭제 수정버튼을 볼 수 있을지 없을지 제어하기 위해 넣습니다.

DB에서 comments라는 이름으로 데이터를 넣었습니다. 데이터가 넣을 때는 무작위로 들어갈 수 있습니다. 데이터 추가되면 업데이트된 데이터베이스에서 가져와 ui를 업데이트합니다.

Read입니다. 댓글리스트를 불러오는 기능은 간단합니다. 쿼리는 데이터베이스에 정렬, 필터 요청방식입니다. 쿼리하는 방식에 따라 데이터를 원하는 형식으로 제어해서 가져올 수 있습니다. 파이어스토에서 제공하는 API를 활용하면 됩니다. getDocs로 요청하고 querySnapshot으로 반환합니다. 객체입니다. forEach는 배열메서드랑 이름만 동일합니다. 하지만 놀랍게도 기능은 동일합니다. 각각의 문서를 순회하고 문서 데이터를 접근할 수 있는 것입니다.

데이터를 순회하고 id를 선택하고 삽입합니다. 배열의 forEach를 순회하면서 appendChild메서드로 붙입니다.

현업에서는 레거시 이외에는 제이쿼리를 볼일은 거의 없습니다.

Update입니다. 화면이 만들어지면 innerHTML로 넣어도 인식할 수 있습니다. 업데이트 버튼을 클릭하면 updateComment 함수가 실행됩니다. event.target의 부모를 접근하는 것도 가능합니다. parent node에 접근해서 id 값을 접근하는 것입니다.

UI는 classList 속성에서 값을 변형해서 css 적용을 받고 안받고 제어하는 것입니다. await는 DB가 업데이트 이후 실행하도록 합니다. DB 상태가 바뀔 때마다 업데이트합니다. CSR이 됩니다. 새로고침할 필요가 없습니다. DB 변경대로 UI 업데이트하면 CSR입니다.

삭제입니다. 문서에서 요구하는 순서에 따라 실행하면 CRUD가 됩니다.

AWS S3에 배포까지해야 합니다. EC2랑 S3 차이를 알게 됩니다. AWS S3는 파이어 스토리지랑 유사합니다. 파일 저장하라고 만든 것입니다. 파이어 베이스의 파이어 스토리지보다 정적 웹사이트 호스팅 베포 URL도 제공합니다. ES2보다 저렴합니다. 서버코드가 없기 때문에 이렇게 해야 합니다. 도메인 네임이랑 버킷 네임은 정확히 똑같이 맞추어야 합니다. 그래야 정확하게 따라야 합니다. S3는 이런 규칙은 따라야 합니다. 업로드하려는 파일은 간단하게 drag & drop합니다. 버킷 정책을 변경해줘야 합니다. ARN은 아마존 리소스 네임입니다. 정책만들고 스니펫을 붙이고 저장하면 배포됩니다.

도메인 적용과정에 대한 지식입니다. DNS에 대한 지식입니다. 브라우저는 도메인을 검색하고 요청하면 사람이 읽을 수 있는 방식으로 요청합니다.

요청은 ip주소로만 요청할 수 있습니다. 그래서 DNS 서버로 먼저 요청합니다. 하지만 DNS 서버는 인터넷 제공기업의 서버입니다. DNS 서버는 요청을 캐싱해놓고 또 요청하면 바로 제공합니다. 하지만 네임 서버는 ip랑 도메인이 일치하는지 여부를 판단하는 것입니다. DNS서버는 캐싱하고 전달만합니다.

웹 개발할 때 EC2로 도메인 연결이 간단한 이유는 직접 ip주소를 등록했기 때문입니다. ip랑 도메인도 가비아에서 모두 일치합니다. 구매랑 사용이 일치하면 연결이 간단합니다. 하지만 S3를 사용하면서 우외해서 ip 주소를 받아야 합니다. DNS 서버가 DNS를 관리해주는 AWS에서 Route 53에서 호스팅을 관리해야 합니다. 도메인을 호스팅 영역으로 등록하고 생성하면 레코드가 생성됩니다. NS는 네임서버에 들어갈 이름들을 가비에 넣어야 합니다. 외부 도메인을 추가하려면 1단계를 더 추가해줘야 합니다.

DNS 서버는 여러개가 있습니다. 네트워크 엔지니어링 지식은 방대합니다. 사용법부터 알고 큰 흐름부터 공부를 시작하도록 합니다. 100% 이해하려면 네트워크 지식만 1달 동안 시간 투입해야 합니다.

제공하는 url뒤에 `.`까지 복사하면 안 됩니다. example.org.에서 org뒤에 해당합니다. 레코드를 간단하게 삭제할 수 없습니다. S3 엔드포인트 input에 자동완성이 되어야 맞출 수 있습니다.

[Firebase - Back to the Basics](https://www.youtube.com/watch?v=q5J5ho7YUhA)

# 특강: Ajax 개념 설명, MPA/SPA 차이 설명

SPA의 탄생배경과 사용이유를 설명하는 특강입니다.

SPA로 갔던 반대부터 시작하겠습니다.

MPA입니다. 요즘 시대에 MPA는 찾기는 어렵습니다. 금융결제원입니다. 이동을 할 때마다 관공서 답게 새로고침이 발생합니다. 서버에서 페이지 전체를 다운로드하게 보냅니다. HTML을 하드코딩해서 클라이언트에게 보냅니다. 당연히 큰 문제는 글자 하나라도 바뀌면 서버에서 다시 처리하고 보내였습니다. 하지만 어느날 구글에서 혁신이 발생했습니다. 검색창에 한 글자를 입력할 때마다 새로고침이 없었습니다. 서버랑 통신을 하지만 새로 고침은 없습니다.

이 기술은 ajax입니다. 비동기방식으로 XML을 이용해서 서버랑 통신합니다. 동적으로 화면을 업데이트합니다. 동적으로 변화를 줄 부분만 서버에서 받아옵니다.

현대 시대는 JSON을 많이 사용하지만 옛날에는 제이쿼리의 구현체로 AJAX입니다. 제이쿼리로 ajax를 사용했습니다.

프론트엔드 영역이 발전하시 시작한 것은 구글의 현식이후부터 입니다. 발전하면서 사람들이 페이지 이동할 때도 모두 업데이트하지말고 Ajax처럼 필요한 부분만 변경하자고 탄생하게 되었습니다. DOM에 접근해서 엘리먼트를 그려주면 됩니다.

당연히 단점도 있습니다. UI만 업데이트하면 뒤로가기를 할 수 없습니다. 여기서 UI를 맵핑하고 뒤로가기를 임의로 만든게 된 것입니다.

원래 랜더링은 서버에서 그려주고 클라이언트에게 전달했습니다. 하지만 이제는 클라이언트에서 그리게 했습니다.

라프텔은 벨로퍼트가 존재하는 곳입니다. 벨로그를 만든 사람이 벨로퍼트입니다.

SPA는 CSR 방식을 사용하는 앱입니다. 존재하는 페이지는 `index.html`만 존재합니다. 하지만 자바스크립트로 DOM조작으로 모두 업데이트하는 것입니다. 실제로는 적은 개수의 페이지로 라우팅할 때 DOM조작이 발생하도록 하는 것입니다.

304는 브라우저가 캐싱한 것을 돌려주는 것입니다. 최초 1회는 SPA가 아닙니다. 그 이후부터 계속 이벤트로 라우팅을 구현해야 SPA가 됩니다. 처음 이니셜 페이지 로드에 모두 다운받게 만들고 로컬에서 가져오는 것입니다. 서버에 요청하지 않고 캐싱해서 가져오기 때문에 SPA입니다.

CSR의 장점도 있지만 SSR 장점도 있는 경우가 있습니다. SPA라고 SSR을 안하는 것은 아닙니다. 기본적인 SPA는 CSR을 사용합니다. 이니셜 페이지 로드에 받아오는 용량이 크기 때문에 SSR을 활용하게 됩니다. 일부 클라이언트에게 전달할 데이터를 덜 전달하고 검색엔진에 유리해지기 위해 SSR를 실행합니다.
